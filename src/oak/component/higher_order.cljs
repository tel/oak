(ns oak.component.higher-order
  "Functions for constructing Components from sub-Components."
  (:require
    [oak.internal.utils :as util]
    [oak.component :as oak]
    [oak.dom :as d]
    [schema.core :as s]))

; -----------------------------------------------------------------------------
; Higher-order components

(defn parallel
  "Construct a *static* component by gluing several subcomponents together
  without interaction. Parallel components are made of a fixed set of named
  subcomponents and have dramatically simplified wiring. Use parallel
  components whenever you do not need custom state management behavior.

  By default, a static component renders its subcomponents in a div in
  arbitrary order. Provide a :view-compositor function to choose how to render
  the subviews more specifically. It has a signature like (view-compositor
  subviews) where `subviews` is a map with the same keys as your static
  components containing ReactElements corresponding to each subcomponent.

  By default, all events generated by a static component are simply routed in
  parallel back to the originating subcomponents. Provide a
  :routing-transform function to choose how events are routed more
  specifically. It has a signature like (routing-transform target event
  continue) where `target` is a key in your subcomponent map, `event` is the
  event headed for that subcomponent, and `continue` is a callback of two
  arguments, the target for the event and the event itself.

  Any other options are forwarded on to `make`."
  [subcomponent-map
   & {:keys [view-compositor routing-transform]
      :or   {view-compositor   (fn [views] (apply d/div {} (vals views)))
             routing-transform (fn [target event cont] (cont target event))}
      :as   options}]

  (let [core-design
        {:state
         (util/map-vals oak/state subcomponent-map)

         :event
         (apply s/conditional
                (mapcat (fn [[target subc]]
                          [(fn [[name subev]] (= name target))
                           (s/pair target :target (oak/event subc) :subevent)])
                        subcomponent-map))

         :step
         (fn static-step [[target event] state]
           (routing-transform
             target event
             (fn [target event]
               (update
                 state target
                 (oak/step
                   (get subcomponent-map target)
                   event)))))

         :merge
         (fn [state result]
           [state result])

         :query
         (fn static-query [state q]
           (util/map-kvs
             (fn [target subc] (oak/query subc (get state target) q))
             subcomponent-map))

         :view
         (fn static-view [[state result] submit]
           (let [subviews (util/map-kvs
                            (fn [target subc]
                              (subc
                                (get state target)
                                (get result target)
                                (fn [ev] (submit [target ev]))))
                            subcomponent-map)]
             (view-compositor subviews)))}]

    ; Let the remaining options override
    (oak/make*
      (merge core-design
             (-> options
                 (dissoc :view-compositor)
                 (dissoc :routing-transform))))))