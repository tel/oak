(ns oak.component
  (:require
    [quiescent.core :as q]
    [oak.internal.utils :as util]
    [oak.dom :as d]))

; -----------------------------------------------------------------------------
; Protocol and type

(defprotocol IComponent
  (stepf [this])
  (factory [this]))

(defprotocol IQueryComponent
  (queryf [this]))

(defn query
  ([it] (queryf it))
  ([it model q] ((queryf it) model q)))

(defn step
  ([it] (stepf it))
  ([it action] (fn transition-fn [model] (step it action model)))
  ([it action model] ((stepf it) action model)))

(deftype Component
  [stepf factory]

  IComponent
  (stepf [_] stepf)
  (factory [_] factory)

  IFn
  (-invoke [_ model submit]
    (factory model submit)))

(deftype QueryComponent
  [stepf queryf factory]

  IComponent
  (stepf [_] stepf)
  (factory [_] factory)

  IQueryComponent
  (queryf [_] queryf)

  IFn
  (-invoke [_ model result submit]
    (factory model result submit)))

(defn normalize
  "Convert a Component to a QueryComponent, opting in to all behavior with
  defaults."
  [comp]
  (QueryComponent.
    (stepf comp)
    (fn [_model _q])
    (fn [model _result submit]
      (comp model submit))))

; -----------------------------------------------------------------------------
; Introduction

(def +oak-option-keys+
  [:step :view :query])

(def +default-options+
  {:step  (fn default-step [_action model] model)

   ; If no query is provided then we will, by default, construct a basic
   ; Component. If one *is* provided we expect that the view function will
   ; receive the result value and then generate a QueryComponent.
   :query nil

   ; By default we use Quiescent, but we're not really married to it in any way.
   ; If you can build a factory in any way, e.g. a function from two args,
   ; the model and the submit function, then you're good! For best
   ; performance, use a Quiescent-style shouldComponentUpdate which assumes
   ; the first arg is all of the state.
   :build-factory
          (fn [{:keys [view] :as options}]
            (let [quiescent-options (apply dissoc options +oak-option-keys+)]
              (q/component view quiescent-options)))})

(defn make* [options]
  (let [options (merge +default-options+ options)
        {:keys [build-factory step query]} options
        factory (build-factory options)]
    (if (nil? query)
      (Component. step factory)
      (QueryComponent. step query factory))))

(defn make [& {:as options}] (make* options))

; -----------------------------------------------------------------------------
; Higher-order components

(defn parallel
  "Construct a *static* component by gluing several subcomponents together
  without interaction. Parallel components are made of a fixed set of named
  subcomponents and have dramatically simplified wiring. Use parallel
  components whenever you do not need custom state management behavior.

  By default, a static component renders its subcomponents in a div in
  arbitrary order. Provide a :view-compositor function to choose how to render
  the subviews more specifically. It has a signature like (view-compositor
  subviews) where `subviews` is a map with the same keys as your static
  components containing ReactElements corresponding to each subcomponent.

  By default, all events generated by a static component are simply routed in
  parallel back to the originating subcomponents. Provide a
  :routing-transform function to choose how events are routed more
  specifically. It has a signature like (routing-transform target event
  continue) where `target` is a key in your subcomponent map, `action` is the
  event headed for that subcomponent, and `continue` is a callback of two
  arguments, the target for the action and the action itself.

  Any other options are forwarded on to `make`."
  [subcomponent-map
   & {:keys [view-compositor routing-transform]
      :or   {view-compositor   (fn [views] (apply d/div {} (vals views)))
             routing-transform (fn [target action cont] (cont target action))}
      :as   options}]

  (let [subcomponent-map (util/map-vals normalize subcomponent-map)

        core-design
        {:step
         (fn static-step [[target action] model]
           (routing-transform
             target action
             (fn [target action]
               (update
                 model target
                 (step
                   (get subcomponent-map target)
                   action)))))

         :query
         (fn static-query [model q]
           (util/map-kvs
             (fn [target subc] (query subc (get model target) q))
             subcomponent-map))

         :view
         (fn static-view [{:keys [model result]} submit]
           (let [subviews (util/map-kvs
                            (fn [target subc]
                              (subc
                                (get model target)
                                (get result target)
                                (fn [ev] (submit [target ev]))))
                            subcomponent-map)]
             (view-compositor subviews)))}]

    ; Let the remaining options override
    (make*
      (merge core-design
             (-> options
                 (dissoc :view-compositor)
                 (dissoc :routing-transform))))))
