(ns oak.core
  (:require
    [schema.core :as s]
    [oak.dom :as d]
    [quiescent.core :as q]))

; -----------------------------------------------------------------------------
; Utilities

(defn ^:private map-kvs [f hashmap]
  (persistent!
    (reduce
      (fn [acc [k v]]
        (assoc! acc k (f k v)))
      (transient {})
      hashmap)))

(defn ^:private map-vals [f hashmap]
  (map-kvs (fn [_ v] (f v)) hashmap))

; -----------------------------------------------------------------------------
; Protocol and type

(defprotocol IComponent
  (state [this])
  (event [this])
  (queryf [this])
  (stepf [this])
  (factory [this]))

(deftype Component
  [state event stepf mergef queryf factory]

  IComponent
  (state [_] state)
  (event [_] event)
  (queryf [_] queryf)
  (stepf [_] stepf)
  (factory [_] factory)

  IFn
  (-invoke [_] (factory (mergef nil nil) (fn [_])))
  (-invoke [_ st] (factory (mergef st nil) (fn [_])))
  (-invoke [_ st submit] (factory (mergef st nil) submit))
  (-invoke [_ st results submit] (factory (mergef st results) submit)))

(defn query
  [it state q] ((queryf it) state q))

(defn step
  ([it event] (fn transition-fn [state] (step it event state)))
  ([it event state] ((stepf it) event state)))

; -----------------------------------------------------------------------------
; Introduction

(def +oak-option-keys+
  [:state :event :step :view :merge :query])

(def +default-options+
  {:state (s/eq nil)
   :event (s/cond-pre) ; never succeeds
   :query (fn [_state _q] nil)
   :merge (fn default-merge [state results] (if results [state results] state))
   :step  (fn default-step [_event state] state)

   ; By default we use Quiescent, but we're not really married to it in any way.
   ; If you can build a factory in any way, e.g. a function from two args,
   ; the state and the submit function, then you're good! For best
   ; performance, use a Quiescent-style shouldComponentUpdate which assumes
   ; the first arg is all of the state.
   :build-factory
          (fn [{:keys [view] :as options}]
            (let [quiescent-options (apply dissoc options +oak-option-keys+)]
              (q/component view quiescent-options)))})

(defn make* [options]
  (let [options (merge +default-options+ options)
        {:keys [build-factory state event step merge query]} options
        factory (build-factory options)]
    (Component. state event step merge query factory)))

(defn make [& {:as options}] (make* options))

(defn static
  "Construct a *static* from a map of other components. Static components are
  made of a fixed set of named subcomponents and have dramatically simplified
  wiring. Use static components whenever you do not need custom state
  management behavior.

  By default, a static component renders its subcomponents in a div in
  arbitrary order. Provide a :view-compositor function to choose how to render
  the subviews more specifically. It has a signature like (view-compositor
  subviews) where `subviews` is a map with the same keys as your static
  components containing ReactElements corresponding to each subcomponent.

  By default, all events generated by a static component are simply routed in
  parallel back to the originating subcomponents. Provide a
  :routing-transform function to choose how events are routed more
  specifically. It has a signature like (routing-transform target event
  continue) where `target` is a key in your subcomponent map, `event` is the
  event headed for that subcomponent, and `continue` is a callback of two
  arguments, the target for the event and the event itself.

  Any other options are forwarded on to `make`."
  [subcomponent-map
   & {:keys [view-compositor routing-transform]
      :or   {view-compositor (fn [views] (apply d/div {} (vals views)))
             routing-transform (fn [target event cont] (cont target event))}
      :as options}]

  (let [core-design
        {:state
         (map-vals state subcomponent-map)

         :event
         (apply s/conditional
                (mapcat (fn [[target subc]]
                          [(fn [[name subev]] (= name target))
                           (s/pair target :target (event subc) :subevent)])
                        subcomponent-map))

         :step
         (fn [[target event] state]
           (routing-transform
             target event
             (fn [target event]
               (update
                 state target
                 (step (get subcomponent-map target) event)))))

         :merge
         (fn [state result]
           [state result])

         :query
         (fn [state q]
           (map-kvs
             (fn [target subc] (query subc (get state target) q))
             subcomponent-map))

         :view
         (fn [[state result] submit]
           (let [subviews (map-kvs
                            (fn [target subc]
                              (subc
                                (get state target)
                                (get result target)
                                (fn [ev] (submit [target ev]))))
                            subcomponent-map)]
             (view-compositor subviews)))}]

    ; Let the remaining options override
    (make* (merge core-design
                  (-> options
                      (dissoc :view-compositor)
                      (dissoc :routing-transform))))))

; -----------------------------------------------------------------------------
; Use

(defn render-once
  "Render a component one time without initiating an update loop. All
  requests must be satisfied and the submission function is a no-op."
  [component state result element]
  (q/render
    (component state result (fn [ev] (println ev)))
    element))
